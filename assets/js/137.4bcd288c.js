(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{401:function(t,a,s){"use strict";s.r(a);var r=s(13),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),a("h3",{attrs:{id:"垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[t._v("#")]),t._v(" 垃圾回收算法")]),t._v(" "),a("ul",[a("li",[t._v("之前：引用计数，没有被引用就清除，但是循环引用的情况会有缺陷")]),t._v(" "),a("li",[t._v("现在：标记清除，会定时循环根 window 对象，看是否还有标记，没有就清除")])]),t._v(" "),a("h3",{attrs:{id:"内存泄漏-memory-leak"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏-memory-leak"}},[t._v("#")]),t._v(" 内存泄漏（Memory Leak）")]),t._v(" "),a("p",[a("code",[t._v("内存泄漏")]),t._v("是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。")]),t._v(" "),a("h3",{attrs:{id:"内存泄漏场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏场景"}},[t._v("#")]),t._v(" 内存泄漏场景")]),t._v(" "),a("ul",[a("li",[t._v("被全局变量、函数引用，组件销毁时未清除")]),t._v(" "),a("li",[t._v("被全局事件、定时器引用，组件销毁时未清除")]),t._v(" "),a("li",[t._v("被自定义事件引用，组件销毁时未清除")])]),t._v(" "),a("h3",{attrs:{id:"闭包是内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包是内存泄漏"}},[t._v("#")]),t._v(" 闭包是内存泄漏？")]),t._v(" "),a("ul",[a("li",[t._v("不符合预期，没有被销毁的才是内存泄漏")]),t._v(" "),a("li",[t._v("闭包虽然不会被垃圾回收机制回收，但是闭包是符合我们预期，不被销毁的，所以闭包不属于内存泄漏")])]),t._v(" "),a("h3",{attrs:{id:"js内存泄漏如何检测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js内存泄漏如何检测"}},[t._v("#")]),t._v(" JS内存泄漏如何检测")]),t._v(" "),a("ul",[a("li",[t._v("使用 performance 检测， 看是否某个地方突然内存增加很多并且没有减回去")]),t._v(" "),a("li",[t._v("正常情况是上上下下，内存增加销毁、增加销毁~~")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/assets/notes-images/depth/performance.png"),alt:"performance",width:"800"}})])}),[],!1,null,null,null);a.default=e.exports}}]);